---
title: 第四章 复合类型 指针 
date: 2026-01-14 17:00:00
tags: [C++笔记]
categories: [C++笔记]
cover: 
description: 指针  4.7 new delete 动态数组
---
# C++ primer plus 笔记


## 第四章 复合类型-指针相关
### 指针和自由存储空间
- 信息存储在何处
- 存储的值是多少
- 存储的信息是什么类型
```
int a = 6;
double  b = 4.5;
```
其中a的值为6，*a为6，&a是a的值储存的地址。**值是指定的，地址是派生的。**
当我们cout a和b的地址后可以看到a的小于b的，a的存储位置要低于b，先放a再放b，差值为int的4个字节。
```cpp
#include<iostream>
int main()
{
	using namespace std;
	int a = 6;
	cout << "a is "<<a<<endl;
	cout <<"a  address is "<<&a<<endl;
	int* p_a  ;
	p_a = &a ;
	cout << "p_a is " << *p_a << endl;
	cout << "p_a  address is " << p_a << endl;
	return 0;
}
```
指针则相反，**地址是指定的量，值是派生的量**
```text
a is 6
a  address is 0000006B34CFFC54
p_a is 6
p_a  address is 0000006B34CFFC54
```
可以看出两个地址是一样的，因为我们把a的地址指给了p_a。
```cpp
#include<iostream>
int main()
{
	using namespace std;
	int a = 6;
	cout << "a is "<<a<<endl;
	cout <<"a  address is "<<&a<<endl;
	int* p_a  ;
	p_a = &a ;
	cout << "p_a is " << *p_a << endl;
	cout << "p_a  address is " << p_a << endl;
	*p_a = *p_a+1;
	cout << "p_a is " << *p_a <<", address "<<p_a <<endl;
	return 0;
}
```
```text
a is 6
a  address is 00000070467FF634
p_a is 6
p_a  address is 00000070467FF634
p_a is 7, address 00000070467FF634
```
可以看出值 + 1 ，但是地址不会变，把值7赋给地址，覆盖原来的6。

### 4.7.4 使用new来分配
- new根据类型分配内存，如2个字节的int型还是4个字节的char类型.      
 ```int * pn = new int;```表示需要存储int的内存,(**我们需要告知我们需要的类型**)new运算符确定需要多少字节的内存找到后并返回地址,接下来将地址赋给pn,pn被声明为指向int的指针,pn是地址*pn是存储在该地址的值.
- ```int higgens ; int * pt = &higgens;```
可以通过higgens名称来访问该int,但是第一种只能通过指针访问未命名的int空间.
#include<iostream>
```cpp
#include<iostream>
int main()
{
	using namespace std;
	int nights = 1001;
	cout<< "nights velue = ";
	cout << nights<<" location is "<< &nights<<endl;
	int * pt = new int;//new 开辟新int地址
	*pt = 1001;
	cout << "int = "<<*pt<<" location "<<pt<<endl;
	double * pn = new double;//new 开辟新double地址
	*pn = 10000001.0;
	cout << "double = " << *pn << " location " << pn << endl;
	cout << "size of pt= "<<sizeof pt<<endl;
	cout<< "size of *pt= "<<sizeof *pt<<endl;
	cout << "size of pn= " << sizeof pn << endl;
	cout << "size of *pn= " << sizeof * pn << endl;
	return 0;
}
```
必须声明指针指向的类型,new运算符会开辟针对的内存空间.
```text
nights velue = 1001 location is 000000E6D7B0F944
int = 1001 location 000002A763B552C0
double = 1e+07 location 000002A763B61530
size of pt= 8
size of *pt= 4
size of pn= 8
size of *pn= 8
```
计算机64位,64/8=8所以pt的地址分了八个字节.32位的会分4个.

### 4.7.5 使用delete释放内存
使用delete释放的只是空间,而不会删除指针本身.可以将原指针指向另一个内存空间.
每用new分配一个内存块,相应的就要用delete释放一个内存块,否则会出现内存泄露的问题.严重时会因一直寻找地址导致程序找不到更多内存而终止.也不允许重复delete已经释放的内存块.
```cpp
#include<iostream>
int main()
{
	using namespace std;
	int nights = 1001;
	cout<< "nights velue = ";
	cout << nights<<" location is "<< &nights<<endl;
	int * pt = new int;//new 开辟新int地址
	*pt = 1001;
	cout << "int = "<<*pt<<" location "<<pt<<endl;
	double * pn = new double;//new 开辟新double地址
	*pn = 10000001.0;
	cout << "double = " << *pn << " location " << pn << endl;
	return 0;
}
```
上面的代码我们可以 ```delete pt;delete pn;```
不可以delete nights,因为delete只能释放new运算符分配的内存空间.
一般来说不要创建两个指向同一个内存块的指针,因为这样会增加错误地删除一个内存块两次的可能性.
### 4.7.6 使用new来创建动态数组
使用new在运行阶段需要时创建数组.不需要时则不创建.

 ***例如100个数据中有个别数据长度较长时则开辟对应的内存空间***
 
 **如何使用new运算符创建数组以及如何使用指针访问数组:**
- 创建                                                       
``` int * psome = new int [10];//开辟10个int元素的数组```       
 上面是开辟新的动态数组,用delete释放new建的内存空间,同样的也要释放数组.   
 ```delete [] psome;//释放new建的动态数组内存```
 - 使用
```cpp
#include<iostream>
int main()
{
	using namespace std;
	double * psome = new double[3];
	psome[0] = 0.2;
	psome[1] = 0.5;
	psome[2] = 0.8;
	cout<<"*psome= "<<*psome<<endl;
	cout<<"psome[0]= "<<psome[0]<<endl;
	cout << "psome[1]= " << psome[1] << endl;
	cout << "psome[2]= " << psome[2] << endl;
	psome=psome+1;//后移8个字节
	cout << "psome[0]= " << psome[0] << endl;
	psome = psome - 1;//前移回去8个字节
	cout << "psome[0]= " << psome[0] << endl;
	delet [] psome;//释放内存
	return 0;
}
```
```text
*psome= 0.2
psome[0]= 0.2
psome[1]= 0.5
psome[2]= 0.8
psome[0]= 0.5
psome[0]= 0.2
```
可以修改指针的值（普通数组也可以），不可以修改数组名的值。