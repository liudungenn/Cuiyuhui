---
title: 第四章 复合类型 类型组合
date: 2026-01-20 17:00:00
tags: [C++笔记]
categories: [C++笔记]
cover: 
description:   4.9 类型组合
---
# C++ primer plus 笔记


## 第四章 复合类型-类型组合
### 4.9 类型组合
struct ant
{
	int year;
};
- 1、ant s01,s02,s03;
使用成员运算符s01.year=1998;访问其成员。
- 2、还可以创建 ant * pa = &s02；
间接运算符访问其成员pa->1999; 把1999的地址赋给s02，pa指向ant，地址是s02的地址；
- 3、ant trio[3]；
通过成员运算符访问其成员，trio[0].year = 2003;把2003赋值给数组，也就是第一个元素的地址。
(trio + 1) - > year =2004;
把2004赋给第二个元素的地址。
- 4、const ant * arp[3] ={&s01,&s02,&s03};
间接成员运算符访问数组，以访问成员：cout << arp[0]->year<<endl;
把s01，s02，s03的值赋给指针数组的三个指针arp[0],arp[1],arp[2].
- 5、const ant ** ppa = arp;
ant**ppa ppa是一个指针，ant *指向结构体的指针（就像int *）指向结构体指针的指针,arp是一个指向ant指针的指针。
- 6、auto ppb = arp；
arp对应的是4中的s01的地址。是1998；也就是ppb是s01是1998，ppb+1是s02是1999
cout<< (*ppa)->year<<endl;
cout<< (*(ppb+1))->year<<endl;
下面用程序验证
```cpp
#include<iostream>
struct ant
{
	int year;
};
int main()
{
	using namespace std;
	ant s01, s02, s03;
	s01.year =1998;
	ant * pa = &s02;
	pa->year = 1999;
	ant trio[3];
	trio[0].year = 2003;
	(trio + 1)->year = 2004;
	cout << trio->year << endl;
	const ant * arp[3] = { &s01,&s02,&s03 };
	cout << arp[1]->year << endl;
	const ant ** ppa = arp;
	auto ppb = arp;
	cout << (*ppa)->year<<endl;
	cout<<(*(ppb+1))->year<<endl;
	return 0;
}
```
```text
2003
1999
1998
1999
```





