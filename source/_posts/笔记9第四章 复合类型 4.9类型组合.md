---
title: 第四章 复合类型
date: 2026-01-20 17:00:00
tags: [C++笔记]
categories: [C++笔记]
cover: 
description:   4.9 类型组合4.10 数组的替代品
---
# C++ primer plus 笔记


## 第四章 复合类型- 4.9 类型组合4.10 数组的替代品
### 4.9 类型组合
struct ant
{
	int year;
};
- 1、ant s01,s02,s03;
使用成员运算符s01.year=1998;访问其成员。
- 2、还可以创建 ant * pa = &s02；
间接运算符访问其成员pa->1999; 把1999的地址赋给s02，pa指向ant，地址是s02的地址；
- 3、ant trio[3]；
通过成员运算符访问其成员，trio[0].year = 2003;把2003赋值给数组，也就是第一个元素的地址。
(trio + 1) - > year =2004;
把2004赋给第二个元素的地址。
- 4、const ant * arp[3] ={&s01,&s02,&s03};
间接成员运算符访问数组，以访问成员：cout << arp[0]->year<<endl;
把s01，s02，s03的值赋给指针数组的三个指针arp[0],arp[1],arp[2].
- 5、const ant ** ppa = arp;
ant**ppa ppa是一个指针，ant *指向结构体的指针（就像int *）指向结构体指针的指针,arp是一个指向ant指针的指针。
- 6、auto ppb = arp；
arp对应的是4中的s01的地址。是1998；也就是ppb是s01是1998，ppb+1是s02是1999
cout<< (*ppa)->year<<endl;
cout<< (*(ppb+1))->year<<endl;
下面用程序验证
```cpp
#include<iostream>
struct ant
{
	int year;
};
int main()
{
	using namespace std;
	ant s01, s02, s03;
	s01.year =1998;
	ant * pa = &s02;
	pa->year = 1999;
	ant trio[3];
	trio[0].year = 2003;
	(trio + 1)->year = 2004;
	cout << trio->year << endl;
	const ant * arp[3] = { &s01,&s02,&s03 };
	cout << arp[1]->year << endl;
	const ant ** ppa = arp;
	auto ppb = arp;
	cout << (*ppa)->year<<endl;
	cout<<(*(ppb+1))->year<<endl;
	return 0;
}
```
```text
2003
1999
1998
1999
```
### 4.10 数组的替代品

- vector的使用方法：必须包含头文件，同时包含在空间std中，
vector <typename>vt(n_elem);其中n_elem可以是整型常量也可以是整型变量。
- array的使用方法：必须包含头文件，同时包含在空间std中，
array<typename,n_elem>arr;其中n_elem不可以是变量，因为她的长度是固定的。
```cpp
#include<iostream>
#include<vector>
#include<array>
int main()
{
	using namespace std;
	double a1[4] = {1.3,1.5,2.4,3.1};
	vector <double>a2(4);
	/*vector <double>a2= { 1.3,1.5,2.4,3.1 };*/
	a2[0]=1.0/2.5;
	a2[1] = 1.0 / 2.2;
	a2[2] = 1.0 / 3.5;
	a2[3] = 1.0 / 5.9;
	array <double,4>a3={1.3,1.6,1.8,2.1};
	array <double,4>a4;
	a4=a3;
	cout << "a1[2]=" << a1[2] << " at " << &a1[2] << endl;
	cout << "a2[2]=" << a2[2] << " at " << &a2[2] << endl;
	cout << "a3[2]=" << a3[2] << " at " << &a3[2] << endl;
	cout << "a4[2]=" << a4[2] << " at " << &a4[2] << endl;
	a1[-2]=2.9;
	cout << "a1[-2]=" << a1[-2] << " at " << &a1[-2] << endl;
	return 0;
}
```
```text
a1[2]=2.4 at 00000067DBAFF748
a2[2]=0.285714 at 00000205809CF4A0
a3[2]=1.8 at 00000067DBAFF7C8
a4[2]=1.8 at 00000067DBAFF808
a1[-2]=2.9 at 00000067DBAFF728
```
a1[-2]=2.9;没有报错，是因为数组识别a[0]是第一个，a[-2] 是（a1-2），c++并不检查这种越界错误。当然我们可以手动禁止也就是at（）a2.at(1)=2.3;等价于a2[1]=2.3;








