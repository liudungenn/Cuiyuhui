---
title: 第四章 复合类型 指针4.8 
date: 2026-01-19 17:00:00
tags: [C++笔记]
categories: [C++笔记]
cover: 
description: 指针  4.8 指针、数组和指针算数
---
# C++ primer plus 笔记


## 第四章 复合类型-指针相关
### 4.8 指针、数组和指针算数
#### 4.8.1　 程序说明
```cpp
#include<iostream>
int main()
{
	using namespace std;
	double wages[3] = { 1000.0,2000.0,3000.0 };
	short stacks[3] = { 3,2,1 };
	double* pw = wages;
	cout << "pw=" << pw << " *pw=" << *pw << endl;
	cout << "&wages=" << &wages << ",wages[0]=" <<wages[0]<< ", *wages=" << wages << endl;
	pw = pw + 1;
	cout << "pw=" << pw << ", *pw=" << *pw << endl;
	short* ps = &stacks[0];
	cout << "ps=" << ps << ", *ps=" << *ps << endl;
	ps = ps + 1;
	cout << "ps=" << ps << ", *ps=" << *ps << endl;
    cout<<"stacks is "<<sizeof(stacks) << "pw is " <<sizeof pw << " wages is "<<sizeof wages <<endl;

	return 0;
}
```
```
pw=000000224075F9F8 *pw=1000
&wages[0]=000000224075F9F8,wages[0]=000000224075F9F8, *wages=000000224075F9F8
pw=000000224075FA00, *pw=2000
ps=000000224075FA24, *ps=3
ps=000000224075FA26, *ps=2
stacks is 6 pw is 8 wages is 24
```
数组名做指针stackes[1] = *(stacks+1),仅为元素地址偏移。           
arrayname[i] becomes *(arrayname + i)数组                        
pointname[i] becomes *(pointname + i)指针                       
所以指针可以使用数组名。

wages和&wages都是数组的地址，为第一个元素，wages[0]取得是第一个值的地址，虽然相同，但意思不同。&wages是数组，可以将数组赋给指针.     
double （*pa） [10] = &wages;
这是个数组指针，*pa和wages是等价的，（ *p ）[0]的值就是wages数组的第一个值。
#### 4.8.3　 指针和字符串
在cout和多数C++表达式中,char数组名\char指针以及用引号括起来的字符串常量都被解释为字符串第一个字符的地址.
```cpp
#include<iostream>
#include<cstring>
#pragma warning(disable:4996)
int main()
{
	using namespace std;
	char animal[20] = "bear";
	const char * bird ="wren";//不加const系统默认有可能对字符串常量进行修改
	char * ps;//只声明该指针不初始化
	cout << animal<<" and " << bird << endl;
	cout<< "enter a kind of animal:"<<endl;
	cin>>animal;
	ps = animal;
	cout << ps<<endl;
	cout <<"before using strcpy():\n";
	cout << animal<<" at "<<(int *)animal<<endl;
	cout << ps << " at " << (int*)ps << endl;//强制转换可以看到ps的地址
	ps = new char [strlen(animal)+1];//获取animal的字符串长度加上\0
	strcpy(ps,animal);
	cout << "after using strcpy():\n";
	cout << animal << " at " << (int*)animal << endl;
	cout << ps << " at " << (int*)ps << endl;
	return 0;
}
```

```text
bear and wren
enter a kind of animal:
fox
fox
before using strcpy():
fox at 00000045E87BF718
fox at 00000045E87BF718
after using strcpy():
fox at 00000045E87BF718
fox at 000001AD071C5570
```
上面我们用strlen获取字符串长度,再加上"\0"的长度,用new运算符开辟一个空间将这个内存空间分配给ps,同时用strcpy拷贝animal的字符给ps,这样就将animal储存在了ps的内存空间.其中我们无法像别的数据类型一样直接获取字符串的地址,因为它将会读取字符而不是地址,程序中我们用强制转换将char类型转换成整型,取出储存地址.
const char * bird ="wren";我们用const是为了用bird直接访问字符串,但是不能修改.
#### 4.8.4　 使用new来创建动态结构
在运行时创建数组优于在编译时创建数组,对于结构也是如此.我们可以用new来创建动态结构,也就是在运行时而不是在编译时,将new用于结构有两步可以完成,创建结构和访问其成员.
要创建一个未命名的inflatable类型并将其赋给一个指针可以这样:
inflatable * pa = new inflatable;
运算符是->上面我们可以表示为ps->price,还有一种方法,*ps就是所指向的值--结构本身.由于 *ps是一个结构,因此( *ps).price也是一种表示方法.
```cpp
#include<iostream>
struct inflatable
{
char name[20];
float volume;
double price;
};
int main()
{
	using namespace std;
	inflatable * ps = new inflatable;
	cout << "enter name of inflatable itme:";
	cin.get(ps->name,20);
	cout << "enter volume of inflatable itme:";
	cin>>(*ps).volume;
	cout << "enter price of inflatable itme:";
	cin>>ps->price;
	cout<<"name :"<<ps->name<<endl;
	cout << "volume :" << (*ps).volume << endl;
	cout << "price$ :" << ps->price << endl;
	delete ps;
	return 0;
}
```

```text
enter name of inflatable itme:cui yuhui
enter volume of inflatable itme:12.21
enter price of inflatable itme:26.14
name :cui yuhui
volume :12.21
price$ :26.14
```
上面演示的是创建一个未命名的结构,并用两种方法访问它.
下面是使用new和delete的示例:
```cpp
#include<iostream>
#include<cstring>
#pragma warning(disable:4996)
char * getname(void);
using namespace std;
int main()
{
	char * name ;
	name = getname();
	cout<<name<<" at "<<(int*)name<<endl;
	delete []name;
	return 0;
}
char * getname()
{
	char temp[80];
	cout<<"enter ur name :";
	cin>>temp;
	char * pn = new char[strlen(temp) +1];
	strcpy(pn,temp);
	return pn;
}
```
```text
enter ur name :fredeldumpkin
fredeldumpkin at 00000188085C1BC0
```
程序说明:
上面程序我们用了getname(),还用了strlen来获取临时变量收到的字符串长度加上"\0"后用new开辟一个对应的内存空间,再将临时变量的字符复制粘贴到pn,函数返回pn,这是字符串副本的地址.main()中,返回值(地址)被赋给指针name,该指针是在main()中定义的,但它指向getname()函数中分配的内存块.然后程序就打印该字符串及地址.
上面程序我们是在getname()中new了新的内存,在main()中detele的,分开放置是可以的.
#### 4.8.5　 自动存储\静态存储和动态存储
----
